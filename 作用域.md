# 作用域


## 问题

作用域到底是什么? 我们在学习Js的时候能听到很多关于作用域的名次:
函数作用域、块级作用域、词法作用域等等,那么它到底指的是什么呢?

其实作用域用一句话就可以说明: **根据名称查找变量的一套规则,也就是确定当前代码对变量的访问权限**.没了!!!
是不是很简单呢? 可能你会有很多问好? What? 就这? 没了?
且听我慢慢向你细说.


## 演员表

- 引擎: 负责整个JavaScript的编译及执行过程
- 编译器: 负责语法分析及代码生成
- 作用域:负责收集并维护由所有声明的变量组成的一系列查询,并实施一套严格的规则,确定当前执行代码对这些标识符的访问权限


## 变量赋值

`var a = 2`经历了什么?

1. 遇到var a, 编译器会在当前作用域查找是否有一个该名称的变量,如果有的话,编译器忽略该声明,继续进行编译,否则它会要求作用域在当前作用域的集合中声明一个新的变量,命名为a

2. 编译器会为引擎生成运行时所需的代码,这些代码被用来处理a = 2这个赋值操作. 引擎运行时会首先询问作用,在当前作用域集合中是否存在一个叫做a的变量. 如果是,引擎则直接使用该变量,否则,引擎会根据作用域规则查找该变量.

如果上面的话看起来懵懵懂懂的话, 简单的来说就是: **变量的赋值操作会执行两个动作,首先编译器编译时在当前作用域中声明一个变量(如果之前没有声明过),然后在运行时引擎在作用域中查找该变量,如果能找到就对它赋值**.


## LHS、RHS

编译器在编译过程中生成了可执行代码, 引擎执行怎样的查找,会影响到最终的查找结果.看到"L"和"R",我们能够联想到"left"和"right", 其实就是赋值操作的左侧和右侧, 换句话来说:**当变量出现在复制操作的左侧时进行LHS查询, 出现在右侧时进行RHS查询**.

更加准确一点的说: RHS查询就是简单的查找某个变量,而LHS查询就是找到变量容器本身,从而进行赋值.

举个例子:

```javascript
function foo(a){
    console.log(a)
}

foo(2)
```

foo函数调用需要foo进行RHS引用,意味着:"去找到foo的值,把它给我",


## 作用域嵌套

我们说过, 作用域是根据名字查找变量的一套规则,实际情况中,通常需要同时顾及几个作用域

那么这个时候怎么进行查找呢?

遍历嵌套作用域链的规则很简单:
引擎从当前作用域开始查找变量,如果找不到,就向上一级继续查找,当抵达最外层的全局作用域时,无论找到还是没找到,查找过程都会停止.

把作用域链比喻成一个建筑就很好理解了:

<img src="/Users/itsuki/Downloads/fig1.png" alt="fig1" style="zoom:50%;" />

这个建筑物表示我们程序的嵌套作用域规则集合。无论你在哪里，建筑的第一层表示你当前作用域。建筑的顶层表示全局作用域。

你通过在你当前的楼层中查找来解析 LHS 和 RHS 引用，如果你没有找到它，就坐电梯到上一层楼，在那里寻找，然后再上一层，如此类推。一旦你到了顶层（全局作用域），你要么找到了你想要的东西，要么没有。但是不管怎样你都不得不停止了。

## 异常

为什么要区分LHS和RHS呢?

因为变量还没有声明的情况下,这两种查询的行为是不一样的.

- 如果是RHS查询所有嵌套的作用域中找寻不到该变量,引擎就会跑出ReferenceError异常, xxx变量未定义.
- 当引擎执行LHS查询时,如果在全局作用域也无法找到目标变量,全局作用域中就会创建一个该名称的变量,并将它返还给引擎(前提是在非"严格模式"下)
- 如果是RHS找到了一个变量,但是对其值进行不合理的操作,比如说对一个基本数据类型进行函数调用则会抛出TypeError异常,类型引用异常.

ReferenceError是没有在所有嵌套的作用域中找到, 而TypeError是在作用域中找到了,但是对其结果操作不合法.

## 词法作用域

词法作用域定义在词法阶段的作用域,也就是说函数的作用域在**函数定义**的时候就决定了.
而与词法作用域相对应的就是动态作用域,函数的作用域在**函数调用**的时候才决定,
JavaScript采用的词法作用域.

举个例子:

```javascript
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

因为JavaScript采用的词法作用域,所以答案是1, 我们分开两个方面来看, 第一:函数调用顺序: bar -> foo, 第二: 作用域查找顺序: foo -> window, 所以我们可以看到foo函数先看当前作用域有没有变量名为value,没有,所以坐上电梯去了上一层window全局作用域, 喔耶,找到了value = 1,所以打印出来的就是1.

总结: 无论函数在哪里被调用, 也无论它被如何被调用,它的词法作用域都只由函数被声明时所处的位置决定.

## 函数作用域和块作用域

我们都知道JavaScript具有基于函数的作用域,这意味这每一个函数都会为其自身创建一个函数作用域.




